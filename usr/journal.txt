
# 190123

Trying a simpler parser that just classifies the tokens on the line. Then, I can have another pass check the syntax for whether there's a value continuation followed by a list sub element. When I'm there, I'm inclined to make a tree of ContainerElement, which will be section or 'field'. When looking through, I'll cast to the appropriate subclass based on the type. I'm not going to give the base class everything. I'll just have to deal with the consequence of that, rather than carry a map and list and string on every element, even components. Time over space, this round.

# 190121

Oh, his 'templated fields and blocks should not permit continuations' rfc needs to be rejected in syntax analysis (maybe) or syntax needs to leave a mark on the field, such that semantic analysis will notice the continued value field on a templated field and reject it. I can worry about it when I actually build the tree.
To be clear, I may be 'interpreting' these values too early. Which is to say, maybe I shouldn't be binding all the values together, so much as recognizing the phrases in each line and just saying what it is. You know: field name ; template name ;; continuation ;; comment. Then semantic analysis vets whether there's a map list combo in the same field or whatever. Maybe.
Actually, maybe I should do exactly that. Parser then produces a list of lines, which are a list of phrases. It can hand that to a syntax analyzer that will actually check for things like a continuation below a templated field. That sounds a bit like semantic analysis, but the latter will perform the template operations and prep the symbol table (Or each section has its own symbol table?)

# 190119

Working on recognizing. Make sure that these things that try next line inflexibly don't just try forever. Consider catching with the complaining version, to know when to break. Or, if I have a thing that knows when the document is fully recognized (no lines left), break and let the stack unwind.

Jumping back from field value (or list) into field any, rather than directly to section interior, seems like it will be less complicated. I'm probably just struggling against the areas where I'm not top down parsing. Oh well.

# 181209

I've still not decided whether I should just recognize the line type or put the entire value together. Which is to say, whether I recognize a line continuation and leave it there or if I have semantic analysis ensure that it gets put together. Well, I'm only going to recognize things for now. In that regard, I'm already on the right path, given that only field interior will recognize line continuations. It's probably worth noting that, if field interior is too complex, I should extract methods to recognize list elements or sets. It's a bit strange that field interior may have to dump from set to section interior or a different field interior, for sets.

I've idly thought of giving Phrase a list of phrases so that it can become a tree. But then I'll need to traverse a tree.

The section interior portions that complain should note that I need to substitute the canon complaint and throw a RuntimeException, if they don't already.

In field, I took the rest of the line as the field. That might have whitespace. Trim the rest of line (assuming I've already not found a copy operator).

# 181208

Ensure that Lexeme and Syntaxeme have disjoint names so I can static import them rather than have the class name noise.

Send a delimiter character to unescaped name. I'll be using it for maps (ie their delimiter is = but section level fields delimit with : ).

# 181207

Verb names for the semantic analyzer : impute, attribute, reckon, ascribe.

# 181114

The compiler book I've read suggests that I let Lexer keep the last lexeme's text representation. That way, instead of carrying around copies of the text of keywords (single char operators in this case), I can just save text for the parsemes that matter, ie text. Maybe I'd have a length for continuable operators (ex section), rather than the entire string.





















